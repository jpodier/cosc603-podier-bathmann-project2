Task 6
No, renaming the parameter is not an omission on the part of Eclipse. The name of the parameter for the setter method is not related whatsoever to the field variable, except in similarity in name.
The rename command is much different than a find and replace. Eclipse finds all usages of the identifier (field, parameter, method, etc.) and updates each usage with the new name. A find and replace would have also renamed other identifiers that may also have been called owner.

Task 7
Eclipse was able to successfully push down and pull up the available field and its getter and setter. Previewing the change helped identify if the correct actions were being taken.
This type of refactoring is effective at remediating the code duplication, large class, and downcasting design smells. Pulling up the repeated available field and methods was able to reduce duplicated code, which is troublesome for software maintainence because a change made to one code section may not be made in the duplicates. Pushing down may reduce the size of a super class, but should only be performed when at least one subclass does not require the member that is being pushed down. Finally, we saw that pushing up a member can solve the need to downcast when all subclasses can share the same member. This is what caused the compliation errors after pushing down the available field.

Task 8
The getTheOwner and setTheOwner methods were extracted to the IOwnable interface (IOwnable.java). Extracting an interface can solve the downcasting code smell since ownable items no longer need to inherent from the Cell class. This could make the code more maintainable since new ownable items can be more easily added to the game. A new item class would simply need to implement the IOwnable interface. However, the classes that used the owner setter and getter were updated to use the IOwnable interface instead of Cell where possible. This assumes no future use of Cell's other methods or fields will be used in those areas of the code.

Task 9
I chose to include the String array declaration as part of method to extract. Since the owner is a field, the new method would have access to the owner and be able to get an array of the monopolies itself. The calling method no longer needs to care about this detail. The paramter name rentToCharge was a bit misleading since that is what we are attempting to calcuate. Therefore, we changed the name to originalRent and adjusted the new method accordingly.

Task 10
Extracting a local variable can make the code more maintainable by reducing the amount of duplicate code. While this refactoring only eliminated one call to a getter, extracting a local variable is often more useful if the value is unnecessarily calculated multiple times which can increase the chance of errors in the code.
This refactoring is not always a good idea and may impact the correctness of a program, especially for reference types. Consider if between usages of the new local variable, the setter for colorGroup in the cell class was invoked, thereby changing the color group. The local variable would still reference the old value of the color group and may lead to an error.

Task 11
Changing a method signature could eliminate feature envy if the method makes too many inapproprate calls into other classes that would better be handled as paramters. It could also reduce the number of parameters if not all are deemed necessary. Addionally, it could eliminte the need to downcast if the return type is changed to a subclass of the previous return type.
Other are changed due to this refactoring. All the subclasses of Cell were modified to change the signature and add a return statement. Also, any class that invoked the playAction method had to change since a String parameter is now a required argument. Eclipse modified those classes to supply null as the argument. Since the playAction method doesn't do anything with the parameter this is acceptable. But if the string was to be used, all usages of playAction would need to be updated with a meaningful string argument.
